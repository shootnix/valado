/* valado.c generated by valac 0.16.1, the Vala compiler
 * generated from valado.vala, do not modify */

/* Compile: $ valac --pkg sqlite3 valado.vala*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <sqlite3.h>
#include <glib/gstdio.h>


#define TYPE_TASK (task_get_type ())
#define TASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TASK, Task))
#define TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TASK, TaskClass))
#define IS_TASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TASK))
#define IS_TASK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TASK))
#define TASK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TASK, TaskClass))

typedef struct _Task Task;
typedef struct _TaskClass TaskClass;
typedef struct _TaskPrivate TaskPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_VALADO (valado_get_type ())
#define VALADO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VALADO, Valado))
#define VALADO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VALADO, ValadoClass))
#define IS_VALADO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VALADO))
#define IS_VALADO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VALADO))
#define VALADO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VALADO, ValadoClass))

typedef struct _Valado Valado;
typedef struct _ValadoClass ValadoClass;
typedef struct _ValadoPrivate ValadoPrivate;

#define TYPE_STORAGE (storage_get_type ())
#define STORAGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_STORAGE, Storage))
#define STORAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_STORAGE, StorageClass))
#define IS_STORAGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_STORAGE))
#define IS_STORAGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_STORAGE))
#define STORAGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_STORAGE, StorageClass))

typedef struct _Storage Storage;
typedef struct _StorageClass StorageClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _StoragePrivate StoragePrivate;
#define _sqlite3_close0(var) ((var == NULL) ? NULL : (var = (sqlite3_close (var), NULL)))
#define _sqlite3_finalize0(var) ((var == NULL) ? NULL : (var = (sqlite3_finalize (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _Task {
	GObject parent_instance;
	TaskPrivate * priv;
	gint id;
	gchar* task;
};

struct _TaskClass {
	GObjectClass parent_class;
};

struct _Valado {
	GObject parent_instance;
	ValadoPrivate * priv;
};

struct _ValadoClass {
	GObjectClass parent_class;
};

struct _Storage {
	GObject parent_instance;
	StoragePrivate * priv;
};

struct _StorageClass {
	GObjectClass parent_class;
};

struct _StoragePrivate {
	sqlite3* db;
	gint MAX_PRIORITY_VAL;
};


static gpointer task_parent_class = NULL;
static gpointer valado_parent_class = NULL;
static gpointer storage_parent_class = NULL;

GType task_get_type (void) G_GNUC_CONST;
enum  {
	TASK_DUMMY_PROPERTY
};
Task* task_new (gint id, const gchar* task);
Task* task_construct (GType object_type, gint id, const gchar* task);
static void task_finalize (GObject* obj);
GType valado_get_type (void) G_GNUC_CONST;
enum  {
	VALADO_DUMMY_PROPERTY
};
void valado_main (gchar** args, int args_length1);
Storage* storage_new (const gchar* dbfile);
Storage* storage_construct (GType object_type, const gchar* dbfile);
GType storage_get_type (void) G_GNUC_CONST;
Task* storage_get_task (Storage* self, gint id);
void valado_print_usage (void);
gboolean storage_create_task (Storage* self, const gchar* task);
Task** storage_get_tasks_list (Storage* self, gint show_resolved, int* result_length1);
void valado_print_tasks_list (Task** tasks, int tasks_length1);
gint storage_task_priority_up (Storage* self, gint id);
gint storage_task_priority_down (Storage* self, gint id);
gboolean storage_delete_task (Storage* self, gint id);
gboolean storage_task_mark (Storage* self, gint id, const gchar* marker);
gboolean storage_task_unmark (Storage* self, gint id, const gchar* marker);
void storage_resolve_task (Storage* self, gint id);
gboolean storage_unresolve_task (Storage* self, gint id);
Valado* valado_new (void);
Valado* valado_construct (GType object_type);
#define STORAGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_STORAGE, StoragePrivate))
enum  {
	STORAGE_DUMMY_PROPERTY
};
static void _vala_array_add1 (Task*** array, int* length, int* size, Task* value);
static gboolean storage_is_task_exists (Storage* self, const gchar* task);
static gchar* storage_strip_task (Storage* self, const gchar* task);
static gint storage_get_task_priority (Storage* self, gint id);
static void _vala_array_add2 (gint** array, int* length, int* size, gint value);
static void _vala_array_add3 (Task*** array, int* length, int* size, Task* value);
static void _vala_array_add4 (Task*** array, int* length, int* size, Task* value);
static void storage_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


Task* task_construct (GType object_type, gint id, const gchar* task) {
	Task * self = NULL;
	gint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	g_return_val_if_fail (task != NULL, NULL);
	self = (Task*) g_object_new (object_type, NULL);
	_tmp0_ = id;
	self->id = _tmp0_;
	_tmp1_ = task;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (self->task);
	self->task = _tmp2_;
	return self;
}


Task* task_new (gint id, const gchar* task) {
	return task_construct (TYPE_TASK, id, task);
}


static void task_class_init (TaskClass * klass) {
	task_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = task_finalize;
}


static void task_instance_init (Task * self) {
}


static void task_finalize (GObject* obj) {
	Task * self;
	self = TASK (obj);
	_g_free0 (self->task);
	G_OBJECT_CLASS (task_parent_class)->finalize (obj);
}


GType task_get_type (void) {
	static volatile gsize task_type_id__volatile = 0;
	if (g_once_init_enter (&task_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TaskClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) task_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Task), 0, (GInstanceInitFunc) task_instance_init, NULL };
		GType task_type_id;
		task_type_id = g_type_register_static (G_TYPE_OBJECT, "Task", &g_define_type_info, 0);
		g_once_init_leave (&task_type_id__volatile, task_type_id);
	}
	return task_type_id__volatile;
}


void valado_main (gchar** args, int args_length1) {
	Storage* _tmp0_;
	Storage* storage;
	gchar** _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* command;
	gchar** _tmp4_;
	gint _tmp4__length1;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* argument;
	gint SHOW_RESOLVED_TASKS;
	FILE* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	GQuark _tmp11_ = 0U;
	static GQuark _tmp10_label0 = 0;
	static GQuark _tmp10_label1 = 0;
	static GQuark _tmp10_label2 = 0;
	static GQuark _tmp10_label3 = 0;
	static GQuark _tmp10_label4 = 0;
	static GQuark _tmp10_label5 = 0;
	static GQuark _tmp10_label6 = 0;
	static GQuark _tmp10_label7 = 0;
	static GQuark _tmp10_label8 = 0;
	static GQuark _tmp10_label9 = 0;
	static GQuark _tmp10_label10 = 0;
	_tmp0_ = storage_new ("tasks.db");
	storage = _tmp0_;
	_tmp1_ = args;
	_tmp1__length1 = args_length1;
	_tmp2_ = _tmp1_[1];
	_tmp3_ = g_strdup (_tmp2_);
	command = _tmp3_;
	_tmp4_ = args;
	_tmp4__length1 = args_length1;
	_tmp5_ = _tmp4_[2];
	_tmp6_ = g_strdup (_tmp5_);
	argument = _tmp6_;
	SHOW_RESOLVED_TASKS = 0;
	_tmp7_ = stdout;
	fprintf (_tmp7_, "\n");
	_tmp8_ = command;
	_tmp9_ = _tmp8_;
	_tmp11_ = (NULL == _tmp9_) ? 0 : g_quark_from_string (_tmp9_);
	if (_tmp11_ == ((0 != _tmp10_label0) ? _tmp10_label0 : (_tmp10_label0 = g_quark_from_static_string ("-g")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp12_;
				gint _tmp13_ = 0;
				gint id;
				Storage* _tmp14_;
				gint _tmp15_;
				Task* _tmp16_ = NULL;
				Task* task;
				FILE* _tmp17_;
				Task* _tmp18_;
				const gchar* _tmp19_;
				_tmp12_ = argument;
				_tmp13_ = atoi (_tmp12_);
				id = _tmp13_;
				_tmp14_ = storage;
				_tmp15_ = id;
				_tmp16_ = storage_get_task (_tmp14_, _tmp15_);
				task = _tmp16_;
				_tmp17_ = stdout;
				_tmp18_ = task;
				_tmp19_ = _tmp18_->task;
				fprintf (_tmp17_, "TASK: %s\n", _tmp19_);
				_g_object_unref0 (task);
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label1) ? _tmp10_label1 : (_tmp10_label1 = g_quark_from_static_string ("-h")))) {
		switch (0) {
			default:
			{
				valado_print_usage ();
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label2) ? _tmp10_label2 : (_tmp10_label2 = g_quark_from_static_string ("-add")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp20_;
				const gchar* _tmp22_;
				gchar* _tmp23_;
				gchar* task_string;
				Storage* _tmp24_;
				const gchar* _tmp25_;
				Storage* _tmp26_;
				gint _tmp27_;
				gint _tmp28_ = 0;
				Task** _tmp29_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Task** _tmp30_;
				gint _tmp30__length1;
				_tmp20_ = argument;
				if (_tmp20_ == NULL) {
					FILE* _tmp21_;
					_tmp21_ = stdout;
					fprintf (_tmp21_, "[error]: Need task value!\n");
					valado_print_usage ();
					break;
				}
				_tmp22_ = argument;
				_tmp23_ = g_strdup (_tmp22_);
				task_string = _tmp23_;
				_tmp24_ = storage;
				_tmp25_ = task_string;
				storage_create_task (_tmp24_, _tmp25_);
				_tmp26_ = storage;
				_tmp27_ = SHOW_RESOLVED_TASKS;
				_tmp29_ = storage_get_tasks_list (_tmp26_, _tmp27_, &_tmp28_);
				tasks = _tmp29_;
				tasks_length1 = _tmp28_;
				_tasks_size_ = tasks_length1;
				_tmp30_ = tasks;
				_tmp30__length1 = tasks_length1;
				valado_print_tasks_list (_tmp30_, _tmp30__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				_g_free0 (task_string);
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label3) ? _tmp10_label3 : (_tmp10_label3 = g_quark_from_static_string ("-up")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp31_;
				Storage* _tmp33_;
				gint _tmp34_;
				gint _tmp35_ = 0;
				Task** _tmp36_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Task** _tmp37_;
				gint _tmp37__length1;
				const gchar* _tmp39_;
				gint _tmp40_ = 0;
				gint id;
				gint _tmp41_;
				Storage* _tmp43_;
				gint _tmp44_;
				Storage* _tmp45_;
				gint _tmp46_;
				gint _tmp47_ = 0;
				Task** _tmp48_ = NULL;
				Task** _tmp49_;
				gint _tmp49__length1;
				_tmp31_ = argument;
				if (_tmp31_ == NULL) {
					FILE* _tmp32_;
					_tmp32_ = stdout;
					fprintf (_tmp32_, "[error]: Need task number!\n");
					valado_print_usage ();
					break;
				}
				_tmp33_ = storage;
				_tmp34_ = SHOW_RESOLVED_TASKS;
				_tmp36_ = storage_get_tasks_list (_tmp33_, _tmp34_, &_tmp35_);
				tasks = _tmp36_;
				tasks_length1 = _tmp35_;
				_tasks_size_ = tasks_length1;
				_tmp37_ = tasks;
				_tmp37__length1 = tasks_length1;
				if (_tmp37__length1 == 0) {
					FILE* _tmp38_;
					_tmp38_ = stdout;
					fprintf (_tmp38_, "The List is empty\n");
					tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
					break;
				}
				_tmp39_ = argument;
				_tmp40_ = atoi (_tmp39_);
				id = _tmp40_;
				_tmp41_ = id;
				if (_tmp41_ <= 0) {
					FILE* _tmp42_;
					_tmp42_ = stdout;
					fprintf (_tmp42_, "[error]: Need a Natural Number (starts from 0)\n");
					valado_print_usage ();
					tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
					break;
				}
				_tmp43_ = storage;
				_tmp44_ = id;
				storage_task_priority_up (_tmp43_, _tmp44_);
				_tmp45_ = storage;
				_tmp46_ = SHOW_RESOLVED_TASKS;
				_tmp48_ = storage_get_tasks_list (_tmp45_, _tmp46_, &_tmp47_);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				tasks = _tmp48_;
				tasks_length1 = _tmp47_;
				_tasks_size_ = tasks_length1;
				_tmp49_ = tasks;
				_tmp49__length1 = tasks_length1;
				valado_print_tasks_list (_tmp49_, _tmp49__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label4) ? _tmp10_label4 : (_tmp10_label4 = g_quark_from_static_string ("-down")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp50_;
				const gchar* _tmp52_;
				gint _tmp53_ = 0;
				gint id;
				Storage* _tmp54_;
				gint _tmp55_;
				gint _tmp56_ = 0;
				Task** _tmp57_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Task** _tmp58_;
				gint _tmp58__length1;
				gint _tmp60_;
				Storage* _tmp62_;
				gint _tmp63_;
				Storage* _tmp64_;
				gint _tmp65_;
				gint _tmp66_ = 0;
				Task** _tmp67_ = NULL;
				Task** _tmp68_;
				gint _tmp68__length1;
				_tmp50_ = argument;
				if (_tmp50_ == NULL) {
					FILE* _tmp51_;
					_tmp51_ = stdout;
					fprintf (_tmp51_, "[error]: Need a task number!\n");
					valado_print_usage ();
					break;
				}
				_tmp52_ = argument;
				_tmp53_ = atoi (_tmp52_);
				id = _tmp53_;
				_tmp54_ = storage;
				_tmp55_ = SHOW_RESOLVED_TASKS;
				_tmp57_ = storage_get_tasks_list (_tmp54_, _tmp55_, &_tmp56_);
				tasks = _tmp57_;
				tasks_length1 = _tmp56_;
				_tasks_size_ = tasks_length1;
				_tmp58_ = tasks;
				_tmp58__length1 = tasks_length1;
				if (_tmp58__length1 == 0) {
					FILE* _tmp59_;
					_tmp59_ = stdout;
					fprintf (_tmp59_, "The List is empty\n");
					tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
					break;
				}
				_tmp60_ = id;
				if (_tmp60_ <= 0) {
					FILE* _tmp61_;
					_tmp61_ = stdout;
					fprintf (_tmp61_, "[error]: Need a Natural Number (starts from 0)\n");
					valado_print_usage ();
					tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
					break;
				}
				_tmp62_ = storage;
				_tmp63_ = id;
				storage_task_priority_down (_tmp62_, _tmp63_);
				_tmp64_ = storage;
				_tmp65_ = SHOW_RESOLVED_TASKS;
				_tmp67_ = storage_get_tasks_list (_tmp64_, _tmp65_, &_tmp66_);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				tasks = _tmp67_;
				tasks_length1 = _tmp66_;
				_tasks_size_ = tasks_length1;
				_tmp68_ = tasks;
				_tmp68__length1 = tasks_length1;
				valado_print_tasks_list (_tmp68_, _tmp68__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label5) ? _tmp10_label5 : (_tmp10_label5 = g_quark_from_static_string ("-d")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp69_;
				const gchar* _tmp71_;
				gint _tmp72_ = 0;
				gint id;
				Storage* _tmp73_;
				gint _tmp74_;
				gint _tmp75_ = 0;
				Task** _tmp76_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Task** _tmp77_;
				gint _tmp77__length1;
				gint _tmp79_;
				Storage* _tmp81_;
				gint _tmp82_;
				Storage* _tmp83_;
				gint _tmp84_;
				gint _tmp85_ = 0;
				Task** _tmp86_ = NULL;
				Task** _tmp87_;
				gint _tmp87__length1;
				_tmp69_ = argument;
				if (_tmp69_ == NULL) {
					FILE* _tmp70_;
					_tmp70_ = stdout;
					fprintf (_tmp70_, "[error]: Need a task number!\n");
					valado_print_usage ();
					break;
				}
				_tmp71_ = argument;
				_tmp72_ = atoi (_tmp71_);
				id = _tmp72_;
				_tmp73_ = storage;
				_tmp74_ = SHOW_RESOLVED_TASKS;
				_tmp76_ = storage_get_tasks_list (_tmp73_, _tmp74_, &_tmp75_);
				tasks = _tmp76_;
				tasks_length1 = _tmp75_;
				_tasks_size_ = tasks_length1;
				_tmp77_ = tasks;
				_tmp77__length1 = tasks_length1;
				if (_tmp77__length1 == 0) {
					FILE* _tmp78_;
					_tmp78_ = stdout;
					fprintf (_tmp78_, "The List is empty\n");
					tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
					break;
				}
				_tmp79_ = id;
				if (_tmp79_ <= 0) {
					FILE* _tmp80_;
					_tmp80_ = stdout;
					fprintf (_tmp80_, "[error]: Need a Natural Number (starts from 0)\n");
					valado_print_usage ();
					tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
					break;
				}
				_tmp81_ = storage;
				_tmp82_ = id;
				storage_delete_task (_tmp81_, _tmp82_);
				_tmp83_ = storage;
				_tmp84_ = SHOW_RESOLVED_TASKS;
				_tmp86_ = storage_get_tasks_list (_tmp83_, _tmp84_, &_tmp85_);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				tasks = _tmp86_;
				tasks_length1 = _tmp85_;
				_tasks_size_ = tasks_length1;
				_tmp87_ = tasks;
				_tmp87__length1 = tasks_length1;
				valado_print_tasks_list (_tmp87_, _tmp87__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label6) ? _tmp10_label6 : (_tmp10_label6 = g_quark_from_static_string ("-m")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp88_;
				const gchar* _tmp90_;
				gchar* _tmp91_;
				gchar* marker;
				gchar** _tmp92_;
				gint _tmp92__length1;
				const gchar* _tmp93_;
				gchar** _tmp95_;
				gint _tmp95__length1;
				const gchar* _tmp96_;
				gint _tmp97_ = 0;
				gint id;
				gint _tmp98_;
				Storage* _tmp100_;
				gint _tmp101_;
				gint _tmp102_ = 0;
				Task** _tmp103_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Storage* _tmp104_;
				gint _tmp105_;
				const gchar* _tmp106_;
				Storage* _tmp107_;
				gint _tmp108_;
				gint _tmp109_ = 0;
				Task** _tmp110_ = NULL;
				Task** _tmp111_;
				gint _tmp111__length1;
				_tmp88_ = argument;
				if (_tmp88_ == NULL) {
					FILE* _tmp89_;
					_tmp89_ = stdout;
					fprintf (_tmp89_, "[error]: Need a task number!\n");
					valado_print_usage ();
					break;
				}
				_tmp90_ = argument;
				_tmp91_ = g_strdup (_tmp90_);
				marker = _tmp91_;
				_tmp92_ = args;
				_tmp92__length1 = args_length1;
				_tmp93_ = _tmp92_[3];
				if (_tmp93_ == NULL) {
					FILE* _tmp94_;
					_tmp94_ = stdout;
					fprintf (_tmp94_, "[error]: Need task id\n");
					valado_print_usage ();
					_g_free0 (marker);
					break;
				}
				_tmp95_ = args;
				_tmp95__length1 = args_length1;
				_tmp96_ = _tmp95_[3];
				_tmp97_ = atoi (_tmp96_);
				id = _tmp97_;
				_tmp98_ = id;
				if (_tmp98_ <= 0) {
					FILE* _tmp99_;
					_tmp99_ = stdout;
					fprintf (_tmp99_, "[error]: Need a Natural Number (starts from 0)\n");
					valado_print_usage ();
					_g_free0 (marker);
					break;
				}
				_tmp100_ = storage;
				_tmp101_ = SHOW_RESOLVED_TASKS;
				_tmp103_ = storage_get_tasks_list (_tmp100_, _tmp101_, &_tmp102_);
				tasks = _tmp103_;
				tasks_length1 = _tmp102_;
				_tasks_size_ = tasks_length1;
				_tmp104_ = storage;
				_tmp105_ = id;
				_tmp106_ = marker;
				storage_task_mark (_tmp104_, _tmp105_, _tmp106_);
				_tmp107_ = storage;
				_tmp108_ = SHOW_RESOLVED_TASKS;
				_tmp110_ = storage_get_tasks_list (_tmp107_, _tmp108_, &_tmp109_);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				tasks = _tmp110_;
				tasks_length1 = _tmp109_;
				_tasks_size_ = tasks_length1;
				_tmp111_ = tasks;
				_tmp111__length1 = tasks_length1;
				valado_print_tasks_list (_tmp111_, _tmp111__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				_g_free0 (marker);
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label7) ? _tmp10_label7 : (_tmp10_label7 = g_quark_from_static_string ("-um")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp112_;
				const gchar* _tmp114_;
				gchar* _tmp115_;
				gchar* marker;
				gchar** _tmp116_;
				gint _tmp116__length1;
				const gchar* _tmp117_;
				gchar** _tmp119_;
				gint _tmp119__length1;
				const gchar* _tmp120_;
				gint _tmp121_ = 0;
				gint id;
				gint _tmp122_;
				Storage* _tmp124_;
				gint _tmp125_;
				gint _tmp126_ = 0;
				Task** _tmp127_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Storage* _tmp128_;
				gint _tmp129_;
				const gchar* _tmp130_;
				Storage* _tmp131_;
				gint _tmp132_;
				gint _tmp133_ = 0;
				Task** _tmp134_ = NULL;
				Task** _tmp135_;
				gint _tmp135__length1;
				_tmp112_ = argument;
				if (_tmp112_ == NULL) {
					FILE* _tmp113_;
					_tmp113_ = stdout;
					fprintf (_tmp113_, "[error]: Need a task number!\n");
					valado_print_usage ();
					break;
				}
				_tmp114_ = argument;
				_tmp115_ = g_strdup (_tmp114_);
				marker = _tmp115_;
				_tmp116_ = args;
				_tmp116__length1 = args_length1;
				_tmp117_ = _tmp116_[3];
				if (_tmp117_ == NULL) {
					FILE* _tmp118_;
					_tmp118_ = stdout;
					fprintf (_tmp118_, "[error]: Need task id\n");
					valado_print_usage ();
					_g_free0 (marker);
					break;
				}
				_tmp119_ = args;
				_tmp119__length1 = args_length1;
				_tmp120_ = _tmp119_[3];
				_tmp121_ = atoi (_tmp120_);
				id = _tmp121_;
				_tmp122_ = id;
				if (_tmp122_ <= 0) {
					FILE* _tmp123_;
					_tmp123_ = stdout;
					fprintf (_tmp123_, "[error]: Need a Natural Number (starts from 0)\n");
					valado_print_usage ();
					_g_free0 (marker);
					break;
				}
				_tmp124_ = storage;
				_tmp125_ = SHOW_RESOLVED_TASKS;
				_tmp127_ = storage_get_tasks_list (_tmp124_, _tmp125_, &_tmp126_);
				tasks = _tmp127_;
				tasks_length1 = _tmp126_;
				_tasks_size_ = tasks_length1;
				_tmp128_ = storage;
				_tmp129_ = id;
				_tmp130_ = marker;
				storage_task_unmark (_tmp128_, _tmp129_, _tmp130_);
				_tmp131_ = storage;
				_tmp132_ = SHOW_RESOLVED_TASKS;
				_tmp134_ = storage_get_tasks_list (_tmp131_, _tmp132_, &_tmp133_);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				tasks = _tmp134_;
				tasks_length1 = _tmp133_;
				_tasks_size_ = tasks_length1;
				_tmp135_ = tasks;
				_tmp135__length1 = tasks_length1;
				valado_print_tasks_list (_tmp135_, _tmp135__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				_g_free0 (marker);
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label8) ? _tmp10_label8 : (_tmp10_label8 = g_quark_from_static_string ("-r")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp136_;
				const gchar* _tmp138_;
				gint _tmp139_ = 0;
				gint id;
				gint _tmp140_;
				Storage* _tmp142_;
				gint _tmp143_;
				gint _tmp144_ = 0;
				Task** _tmp145_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Storage* _tmp146_;
				gint _tmp147_;
				Storage* _tmp148_;
				gint _tmp149_;
				gint _tmp150_ = 0;
				Task** _tmp151_ = NULL;
				Task** _tmp152_;
				gint _tmp152__length1;
				_tmp136_ = argument;
				if (_tmp136_ == NULL) {
					FILE* _tmp137_;
					_tmp137_ = stdout;
					fprintf (_tmp137_, "[error]: Need a task number!\n");
					valado_print_usage ();
					break;
				}
				_tmp138_ = argument;
				_tmp139_ = atoi (_tmp138_);
				id = _tmp139_;
				_tmp140_ = id;
				if (_tmp140_ <= 0) {
					FILE* _tmp141_;
					_tmp141_ = stdout;
					fprintf (_tmp141_, "[error]: Need a Natural Number (starts from 0)\n");
					valado_print_usage ();
					break;
				}
				_tmp142_ = storage;
				_tmp143_ = SHOW_RESOLVED_TASKS;
				_tmp145_ = storage_get_tasks_list (_tmp142_, _tmp143_, &_tmp144_);
				tasks = _tmp145_;
				tasks_length1 = _tmp144_;
				_tasks_size_ = tasks_length1;
				_tmp146_ = storage;
				_tmp147_ = id;
				storage_resolve_task (_tmp146_, _tmp147_);
				_tmp148_ = storage;
				_tmp149_ = SHOW_RESOLVED_TASKS;
				_tmp151_ = storage_get_tasks_list (_tmp148_, _tmp149_, &_tmp150_);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				tasks = _tmp151_;
				tasks_length1 = _tmp150_;
				_tasks_size_ = tasks_length1;
				_tmp152_ = tasks;
				_tmp152__length1 = tasks_length1;
				valado_print_tasks_list (_tmp152_, _tmp152__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label9) ? _tmp10_label9 : (_tmp10_label9 = g_quark_from_static_string ("-ur")))) {
		switch (0) {
			default:
			{
				const gchar* _tmp153_;
				const gchar* _tmp155_;
				gint _tmp156_ = 0;
				gint id;
				gint _tmp157_;
				Storage* _tmp159_;
				gint _tmp160_;
				gint _tmp161_ = 0;
				Task** _tmp162_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Storage* _tmp163_;
				gint _tmp164_;
				Storage* _tmp165_;
				gint _tmp166_;
				gint _tmp167_ = 0;
				Task** _tmp168_ = NULL;
				Task** _tmp169_;
				gint _tmp169__length1;
				_tmp153_ = argument;
				if (_tmp153_ == NULL) {
					FILE* _tmp154_;
					_tmp154_ = stdout;
					fprintf (_tmp154_, "[error]: Need a task number!\n");
					valado_print_usage ();
					break;
				}
				_tmp155_ = argument;
				_tmp156_ = atoi (_tmp155_);
				id = _tmp156_;
				_tmp157_ = id;
				if (_tmp157_ <= 0) {
					FILE* _tmp158_;
					_tmp158_ = stdout;
					fprintf (_tmp158_, "[error]: Need a Natural Number (starts from 0)\n");
					valado_print_usage ();
					break;
				}
				_tmp159_ = storage;
				_tmp160_ = SHOW_RESOLVED_TASKS;
				_tmp162_ = storage_get_tasks_list (_tmp159_, _tmp160_, &_tmp161_);
				tasks = _tmp162_;
				tasks_length1 = _tmp161_;
				_tasks_size_ = tasks_length1;
				_tmp163_ = storage;
				_tmp164_ = id;
				storage_unresolve_task (_tmp163_, _tmp164_);
				_tmp165_ = storage;
				_tmp166_ = SHOW_RESOLVED_TASKS;
				_tmp168_ = storage_get_tasks_list (_tmp165_, _tmp166_, &_tmp167_);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				tasks = _tmp168_;
				tasks_length1 = _tmp167_;
				_tasks_size_ = tasks_length1;
				_tmp169_ = tasks;
				_tmp169__length1 = tasks_length1;
				valado_print_tasks_list (_tmp169_, _tmp169__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				break;
			}
		}
	} else if (_tmp11_ == ((0 != _tmp10_label10) ? _tmp10_label10 : (_tmp10_label10 = g_quark_from_static_string ("-all")))) {
		switch (0) {
			default:
			{
				Storage* _tmp170_;
				gint _tmp171_ = 0;
				Task** _tmp172_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Task** _tmp173_;
				gint _tmp173__length1;
				_tmp170_ = storage;
				_tmp172_ = storage_get_tasks_list (_tmp170_, 1, &_tmp171_);
				tasks = _tmp172_;
				tasks_length1 = _tmp171_;
				_tasks_size_ = tasks_length1;
				_tmp173_ = tasks;
				_tmp173__length1 = tasks_length1;
				valado_print_tasks_list (_tmp173_, _tmp173__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				Storage* _tmp174_;
				gint _tmp175_;
				gint _tmp176_ = 0;
				Task** _tmp177_ = NULL;
				Task** tasks;
				gint tasks_length1;
				gint _tasks_size_;
				Task** _tmp178_;
				gint _tmp178__length1;
				_tmp174_ = storage;
				_tmp175_ = SHOW_RESOLVED_TASKS;
				_tmp177_ = storage_get_tasks_list (_tmp174_, _tmp175_, &_tmp176_);
				tasks = _tmp177_;
				tasks_length1 = _tmp176_;
				_tasks_size_ = tasks_length1;
				_tmp178_ = tasks;
				_tmp178__length1 = tasks_length1;
				valado_print_tasks_list (_tmp178_, _tmp178__length1);
				tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
				break;
			}
		}
	}
	_g_free0 (argument);
	_g_free0 (command);
	_g_object_unref0 (storage);
}


int main (int argc, char ** argv) {
	g_type_init ();
	valado_main (argv, argc);
	return 0;
}


void valado_print_usage (void) {
	gchar* _tmp0_;
	gchar* usage_info;
	FILE* _tmp1_;
	FILE* _tmp2_;
	FILE* _tmp3_;
	_tmp0_ = g_strdup ("\n" \
"        # Show all tasks:\n" \
"        $ valado\n" \
"\n" \
"        # Add new task:\n" \
"        $ valado -add 'Create a new task'\n" \
"\n" \
"        # Mark task as a resolved:\n" \
"        $ valado -r [id]\n" \
"\n" \
"        # Mark task as an unresolved:\n" \
"        $ valado -ur [id]\n" \
"\n" \
"        # Delete task\n" \
"        $ valado -d [id]\n" \
"\n" \
"        # Priority up:\n" \
"        $ valado -up [id]\n" \
"\n" \
"        # Priority down:\n" \
"        $ valado -down [id]\n" \
"\n" \
"        # Mark task:\n" \
"        $ valado -m [marker] [id]\n" \
"\n" \
"        # Unmark task:\n" \
"        $ valado -um [marker] [id]\n");
	usage_info = _tmp0_;
	_tmp1_ = stdout;
	fprintf (_tmp1_, "Usage:");
	_tmp2_ = stdout;
	fprintf (_tmp2_, "%s", usage_info);
	_tmp3_ = stdout;
	fprintf (_tmp3_, "\n");
	_g_free0 (usage_info);
}


void valado_print_tasks_list (Task** tasks, int tasks_length1) {
	Task** _tmp0_;
	gint _tmp0__length1;
	_tmp0_ = tasks;
	_tmp0__length1 = tasks_length1;
	if (_tmp0__length1 == 0) {
		FILE* _tmp1_;
		_tmp1_ = stdout;
		fprintf (_tmp1_, "The List is empty\n");
	} else {
		FILE* _tmp2_;
		FILE* _tmp19_;
		_tmp2_ = stdout;
		fprintf (_tmp2_, "Current tasks:\n\n");
		{
			gint i;
			i = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					gboolean _tmp4_;
					gint _tmp6_;
					Task** _tmp7_;
					gint _tmp7__length1;
					FILE* _tmp8_;
					Task** _tmp9_;
					gint _tmp9__length1;
					gint _tmp10_;
					Task* _tmp11_;
					gint _tmp12_;
					gchar* _tmp13_ = NULL;
					gchar* _tmp14_;
					Task** _tmp15_;
					gint _tmp15__length1;
					gint _tmp16_;
					Task* _tmp17_;
					const gchar* _tmp18_;
					_tmp4_ = _tmp3_;
					if (!_tmp4_) {
						gint _tmp5_;
						_tmp5_ = i;
						i = _tmp5_ + 1;
					}
					_tmp3_ = FALSE;
					_tmp6_ = i;
					_tmp7_ = tasks;
					_tmp7__length1 = tasks_length1;
					if (!(_tmp6_ < _tmp7__length1)) {
						break;
					}
					_tmp8_ = stdout;
					_tmp9_ = tasks;
					_tmp9__length1 = tasks_length1;
					_tmp10_ = i;
					_tmp11_ = _tmp9_[_tmp10_];
					_tmp12_ = _tmp11_->id;
					_tmp13_ = g_strdup_printf ("%i", _tmp12_);
					_tmp14_ = _tmp13_;
					_tmp15_ = tasks;
					_tmp15__length1 = tasks_length1;
					_tmp16_ = i;
					_tmp17_ = _tmp15_[_tmp16_];
					_tmp18_ = _tmp17_->task;
					fprintf (_tmp8_, "\t%s: %s\n", _tmp14_, _tmp18_);
					_g_free0 (_tmp14_);
				}
			}
		}
		_tmp19_ = stdout;
		fprintf (_tmp19_, "\n\n");
	}
}


Valado* valado_construct (GType object_type) {
	Valado * self = NULL;
	self = (Valado*) g_object_new (object_type, NULL);
	return self;
}


Valado* valado_new (void) {
	return valado_construct (TYPE_VALADO);
}


static void valado_class_init (ValadoClass * klass) {
	valado_parent_class = g_type_class_peek_parent (klass);
}


static void valado_instance_init (Valado * self) {
}


GType valado_get_type (void) {
	static volatile gsize valado_type_id__volatile = 0;
	if (g_once_init_enter (&valado_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValadoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) valado_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Valado), 0, (GInstanceInitFunc) valado_instance_init, NULL };
		GType valado_type_id;
		valado_type_id = g_type_register_static (G_TYPE_OBJECT, "Valado", &g_define_type_info, 0);
		g_once_init_leave (&valado_type_id__volatile, valado_type_id);
	}
	return valado_type_id__volatile;
}


static gint _sqlite3_exec (sqlite3* self, const gchar* sql, sqlite3_callback callback, void* callback_target, gchar** errmsg) {
	gchar* _vala_errmsg = NULL;
	gint result = 0;
	const gchar* sqlite_errmsg = NULL;
	const gchar* _tmp0_;
	sqlite3_callback _tmp1_;
	void* _tmp1__target;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint ec;
	const gchar* _tmp6_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (sql != NULL, 0);
	_tmp0_ = sql;
	_tmp1_ = callback;
	_tmp1__target = callback_target;
	_tmp3_ = sqlite3_exec (self, _tmp0_, _tmp1_, _tmp1__target, (char**) (&_tmp2_));
	sqlite_errmsg = _tmp2_;
	ec = _tmp3_;
	if ((&_vala_errmsg) != NULL) {
		const gchar* _tmp4_;
		gchar* _tmp5_;
		_tmp4_ = sqlite_errmsg;
		_tmp5_ = g_strdup (_tmp4_);
		_g_free0 (_vala_errmsg);
		_vala_errmsg = _tmp5_;
	}
	_tmp6_ = sqlite_errmsg;
	sqlite3_free ((void*) _tmp6_);
	result = ec;
	if (errmsg) {
		*errmsg = _vala_errmsg;
	} else {
		_g_free0 (_vala_errmsg);
	}
	return result;
}


Storage* storage_construct (GType object_type, const gchar* dbfile) {
	Storage * self = NULL;
	gint rc = 0;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* home;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* workdir;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* dbfile_path;
	const gchar* _tmp12_;
	gboolean _tmp13_ = FALSE;
	g_return_val_if_fail (dbfile != NULL, NULL);
	self = (Storage*) g_object_new (object_type, NULL);
	_tmp0_ = g_get_home_dir ();
	_tmp1_ = g_strdup (_tmp0_);
	home = _tmp1_;
	_tmp2_ = home;
	_tmp3_ = g_strconcat (_tmp2_, "/.valado", NULL);
	workdir = _tmp3_;
	_tmp4_ = workdir;
	g_mkdir_with_parents (_tmp4_, 0777);
	_tmp5_ = workdir;
	g_chmod (_tmp5_, 0777);
	_tmp6_ = workdir;
	_tmp7_ = g_strconcat (_tmp6_, "/", NULL);
	_tmp8_ = _tmp7_;
	_tmp9_ = dbfile;
	_tmp10_ = g_strconcat (_tmp8_, _tmp9_, NULL);
	_tmp11_ = _tmp10_;
	_g_free0 (_tmp8_);
	dbfile_path = _tmp11_;
	_tmp12_ = dbfile_path;
	_tmp13_ = g_file_test (_tmp12_, G_FILE_TEST_IS_REGULAR);
	if (!_tmp13_) {
		FILE* _tmp14_;
		const gchar* _tmp15_;
		const gchar* _tmp16_;
		sqlite3* _tmp17_ = NULL;
		gint _tmp18_ = 0;
		gchar* _tmp19_;
		gchar* sql_stmt;
		sqlite3* _tmp20_;
		const gchar* _tmp21_;
		gint _tmp22_ = 0;
		gint _tmp23_;
		_tmp14_ = stdout;
		_tmp15_ = dbfile_path;
		fprintf (_tmp14_, "Storage: creating a new database `%s`...\n", _tmp15_);
		_tmp16_ = dbfile_path;
		_tmp18_ = sqlite3_open (_tmp16_, &_tmp17_);
		_sqlite3_close0 (self->priv->db);
		self->priv->db = _tmp17_;
		rc = _tmp18_;
		_tmp19_ = g_strdup ("\n" \
"                CREATE TABLE `tasks` (\n" \
"                    id        integer NOT NULL PRIMARY KEY AUTOINCREME" \
"NT,\n" \
"                    task      text,\n" \
"                    created   timestamp NOT NULL DEFAULT CURRENT_DATE," \
"\n" \
"                    resolved  timestamp NULL DEFAULT NULL,\n" \
"                    priority  integer NOT NULL DEFAULT 0\n" \
"                )\n" \
"            ");
		sql_stmt = _tmp19_;
		_tmp20_ = self->priv->db;
		_tmp21_ = sql_stmt;
		_tmp22_ = _sqlite3_exec (_tmp20_, _tmp21_, NULL, NULL, NULL);
		rc = _tmp22_;
		_tmp23_ = rc;
		if (_tmp23_ != SQLITE_OK) {
			FILE* _tmp24_;
			_tmp24_ = stderr;
			fprintf (_tmp24_, "Cannot Create a database file\n");
			exit (0);
		}
		_g_free0 (sql_stmt);
	} else {
		const gchar* _tmp25_;
		sqlite3* _tmp26_ = NULL;
		gint _tmp27_ = 0;
		gint _tmp28_;
		_tmp25_ = dbfile_path;
		_tmp27_ = sqlite3_open (_tmp25_, &_tmp26_);
		_sqlite3_close0 (self->priv->db);
		self->priv->db = _tmp26_;
		rc = _tmp27_;
		_tmp28_ = rc;
		if (_tmp28_ != SQLITE_OK) {
			FILE* _tmp29_;
			const gchar* _tmp30_;
			_tmp29_ = stderr;
			_tmp30_ = dbfile_path;
			fprintf (_tmp29_, "Can't open database `%s`", _tmp30_);
		}
	}
	_g_free0 (dbfile_path);
	_g_free0 (workdir);
	_g_free0 (home);
	return self;
}


Storage* storage_new (const gchar* dbfile) {
	return storage_construct (TYPE_STORAGE, dbfile);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _vala_array_add1 (Task*** array, int* length, int* size, Task* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (Task*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


Task** storage_get_tasks_list (Storage* self, gint show_resolved, int* result_length1) {
	Task** result = NULL;
	sqlite3_stmt* stmt = NULL;
	Task** _tmp0_ = NULL;
	Task** tasks;
	gint tasks_length1;
	gint _tasks_size_;
	gchar* _tmp1_;
	gchar* sql;
	gint _tmp2_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	sqlite3* _tmp7_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	sqlite3_stmt* _tmp12_ = NULL;
	gint _tmp13_ = 0;
	gint rc;
	gint _tmp14_;
	Task** _tmp36_;
	gint _tmp36__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_new0 (Task*, 0 + 1);
	tasks = _tmp0_;
	tasks_length1 = 0;
	_tasks_size_ = tasks_length1;
	_tmp1_ = g_strdup ("SELECT id, task, resolved FROM tasks");
	sql = _tmp1_;
	_tmp2_ = show_resolved;
	if (_tmp2_ == 0) {
		const gchar* _tmp3_;
		gchar* _tmp4_;
		_tmp3_ = sql;
		_tmp4_ = g_strconcat (_tmp3_, " WHERE resolved IS NULL", NULL);
		_g_free0 (sql);
		sql = _tmp4_;
	}
	_tmp5_ = sql;
	_tmp6_ = g_strconcat (_tmp5_, " ORDER BY priority DESC", NULL);
	_g_free0 (sql);
	sql = _tmp6_;
	_tmp7_ = self->priv->db;
	_tmp8_ = sql;
	_tmp9_ = sql;
	_tmp10_ = strlen (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp13_ = sqlite3_prepare_v2 (_tmp7_, _tmp8_, _tmp11_, &_tmp12_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp12_;
	rc = _tmp13_;
	_tmp14_ = rc;
	if (_tmp14_ != SQLITE_OK) {
		FILE* _tmp15_;
		_tmp15_ = stderr;
		fprintf (_tmp15_, "Error while selecting data...");
	}
	while (TRUE) {
		sqlite3_stmt* _tmp16_;
		gint _tmp17_ = 0;
		sqlite3_stmt* _tmp18_;
		const gchar* _tmp19_ = NULL;
		gchar* _tmp20_;
		gchar* task_str;
		sqlite3_stmt* _tmp21_;
		const gchar* _tmp22_ = NULL;
		gchar* _tmp23_;
		gchar* resolved_date;
		const gchar* _tmp24_;
		sqlite3_stmt* _tmp27_;
		const gchar* _tmp28_ = NULL;
		gint _tmp29_ = 0;
		gint id;
		gint _tmp30_;
		const gchar* _tmp31_;
		Task* _tmp32_;
		Task* t;
		Task** _tmp33_;
		gint _tmp33__length1;
		Task* _tmp34_;
		Task* _tmp35_;
		_tmp16_ = stmt;
		_tmp17_ = sqlite3_step (_tmp16_);
		if (!(_tmp17_ == SQLITE_ROW)) {
			break;
		}
		_tmp18_ = stmt;
		_tmp19_ = sqlite3_column_text (_tmp18_, 1);
		_tmp20_ = g_strdup (_tmp19_);
		task_str = _tmp20_;
		_tmp21_ = stmt;
		_tmp22_ = sqlite3_column_text (_tmp21_, 2);
		_tmp23_ = g_strdup (_tmp22_);
		resolved_date = _tmp23_;
		_tmp24_ = resolved_date;
		if (_tmp24_ != NULL) {
			const gchar* _tmp25_;
			gchar* _tmp26_;
			_tmp25_ = task_str;
			_tmp26_ = g_strconcat ("\t", _tmp25_, NULL);
			_g_free0 (task_str);
			task_str = _tmp26_;
		}
		_tmp27_ = stmt;
		_tmp28_ = sqlite3_column_text (_tmp27_, 0);
		_tmp29_ = atoi (_tmp28_);
		id = _tmp29_;
		_tmp30_ = id;
		_tmp31_ = task_str;
		_tmp32_ = task_new (_tmp30_, _tmp31_);
		t = _tmp32_;
		_tmp33_ = tasks;
		_tmp33__length1 = tasks_length1;
		_tmp34_ = t;
		_tmp35_ = _g_object_ref0 (_tmp34_);
		_vala_array_add1 (&tasks, &tasks_length1, &_tasks_size_, _tmp35_);
		_g_object_unref0 (t);
		_g_free0 (resolved_date);
		_g_free0 (task_str);
	}
	_tmp36_ = tasks;
	_tmp36__length1 = tasks_length1;
	if (result_length1) {
		*result_length1 = _tmp36__length1;
	}
	result = _tmp36_;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


gboolean storage_create_task (Storage* self, const gchar* task) {
	gboolean result = FALSE;
	gchar* errmsg = NULL;
	const gchar* _tmp0_;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* sql;
	sqlite3* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	gint rc;
	gint _tmp10_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (task != NULL, FALSE);
	_tmp0_ = task;
	_tmp1_ = storage_is_task_exists (self, _tmp0_);
	if (_tmp1_) {
		FILE* _tmp2_;
		const gchar* _tmp3_;
		_tmp2_ = stderr;
		_tmp3_ = task;
		fprintf (_tmp2_, "[error]: Task is already exists: %s\n", _tmp3_);
		result = FALSE;
		_g_free0 (errmsg);
		return result;
	}
	_tmp4_ = task;
	_tmp5_ = g_strdup_printf ("\n" \
"            INSERT INTO tasks (task)\n" \
"            VALUES (\"%s\");\n" \
"        ", _tmp4_);
	sql = _tmp5_;
	_tmp6_ = self->priv->db;
	_tmp7_ = sql;
	_tmp9_ = _sqlite3_exec (_tmp6_, _tmp7_, NULL, NULL, &_tmp8_);
	_g_free0 (errmsg);
	errmsg = _tmp8_;
	rc = _tmp9_;
	_tmp10_ = rc;
	if (_tmp10_ != SQLITE_OK) {
		FILE* _tmp11_;
		const gchar* _tmp12_;
		_tmp11_ = stderr;
		_tmp12_ = errmsg;
		fprintf (_tmp11_, "Database Error: %s\n", _tmp12_);
	}
	result = TRUE;
	_g_free0 (sql);
	_g_free0 (errmsg);
	return result;
}


gboolean storage_delete_task (Storage* self, gint id) {
	gboolean result = FALSE;
	gchar* errmsg = NULL;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* sql;
	sqlite3* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gint rc;
	gint _tmp6_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = id;
	_tmp1_ = g_strdup_printf ("\n" \
"            DELETE FROM tasks\n" \
"            WHERE\n" \
"                id = %d\n" \
"        ", _tmp0_);
	sql = _tmp1_;
	_tmp2_ = self->priv->db;
	_tmp3_ = sql;
	_tmp5_ = _sqlite3_exec (_tmp2_, _tmp3_, NULL, NULL, &_tmp4_);
	_g_free0 (errmsg);
	errmsg = _tmp4_;
	rc = _tmp5_;
	_tmp6_ = rc;
	if (_tmp6_ != SQLITE_OK) {
		FILE* _tmp7_;
		const gchar* _tmp8_;
		_tmp7_ = stderr;
		_tmp8_ = errmsg;
		fprintf (_tmp7_, "Database Error: %s\n", _tmp8_);
		result = FALSE;
		_g_free0 (sql);
		_g_free0 (errmsg);
		return result;
	}
	result = TRUE;
	_g_free0 (sql);
	_g_free0 (errmsg);
	return result;
}


static gchar* storage_strip_task (Storage* self, const gchar* task) {
	gchar* result = NULL;
	GRegex* regex = NULL;
	gchar* _tmp0_;
	gchar* stripped;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (task != NULL, NULL);
	_tmp0_ = g_strdup ("");
	stripped = _tmp0_;
	{
		GRegex* _tmp1_;
		GRegex* _tmp2_;
		_tmp1_ = g_regex_new ("^<|>$", 0, 0, &_inner_error_);
		_tmp2_ = _tmp1_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			_g_free0 (stripped);
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_regex_unref0 (regex);
		regex = _tmp2_;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError* e = NULL;
		FILE* _tmp3_;
		GError* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = stdout;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		fprintf (_tmp3_, "ERROR: %s\n", _tmp5_);
		_tmp6_ = g_strdup ("");
		result = _tmp6_;
		_g_error_free0 (e);
		_g_free0 (stripped);
		_g_regex_unref0 (regex);
		return result;
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_free0 (stripped);
		_g_regex_unref0 (regex);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	{
		GRegex* _tmp7_;
		const gchar* _tmp8_;
		const gchar* _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		gchar* _tmp12_ = NULL;
		gchar* _tmp13_;
		_tmp7_ = regex;
		_tmp8_ = task;
		_tmp9_ = task;
		_tmp10_ = strlen (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_regex_replace (_tmp7_, _tmp8_, (gssize) _tmp11_, 0, "", 0, &_inner_error_);
		_tmp13_ = _tmp12_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			_g_free0 (stripped);
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_free0 (stripped);
		stripped = _tmp13_;
	}
	goto __finally1;
	__catch1_g_regex_error:
	{
		GError* e = NULL;
		FILE* _tmp14_;
		GError* _tmp15_;
		const gchar* _tmp16_;
		gchar* _tmp17_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp14_ = stdout;
		_tmp15_ = e;
		_tmp16_ = _tmp15_->message;
		fprintf (_tmp14_, "ERROR: %s\n", _tmp16_);
		_tmp17_ = g_strdup ("");
		result = _tmp17_;
		_g_error_free0 (e);
		_g_free0 (stripped);
		_g_regex_unref0 (regex);
		return result;
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_free0 (stripped);
		_g_regex_unref0 (regex);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = stripped;
	_g_regex_unref0 (regex);
	return result;
}


void storage_resolve_task (Storage* self, gint id) {
	gchar* errmsg = NULL;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* sql;
	sqlite3* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gint rc;
	gint _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = id;
	_tmp1_ = g_strdup_printf ("\n" \
"            UPDATE tasks SET resolved = CURRENT_DATE\n" \
"            WHERE\n" \
"                id = %d\n" \
"        ", _tmp0_);
	sql = _tmp1_;
	_tmp2_ = self->priv->db;
	_tmp3_ = sql;
	_tmp5_ = _sqlite3_exec (_tmp2_, _tmp3_, NULL, NULL, &_tmp4_);
	_g_free0 (errmsg);
	errmsg = _tmp4_;
	rc = _tmp5_;
	_tmp6_ = rc;
	if (_tmp6_ != SQLITE_OK) {
		FILE* _tmp7_;
		const gchar* _tmp8_;
		_tmp7_ = stderr;
		_tmp8_ = errmsg;
		fprintf (_tmp7_, "Database Error: %s\n", _tmp8_);
	}
	_g_free0 (sql);
	_g_free0 (errmsg);
}


gint storage_task_priority_up (Storage* self, gint id) {
	gint result = 0;
	gchar* errmsg = NULL;
	gint _tmp0_;
	gint _tmp1_ = 0;
	gint current_priority;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gchar* _tmp5_ = NULL;
	gchar* sql;
	sqlite3* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	gint rc;
	gint _tmp10_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = id;
	_tmp1_ = storage_get_task_priority (self, _tmp0_);
	current_priority = _tmp1_;
	_tmp2_ = current_priority;
	_tmp3_ = self->priv->MAX_PRIORITY_VAL;
	if (_tmp2_ >= _tmp3_) {
		result = 0;
		_g_free0 (errmsg);
		return result;
	}
	_tmp4_ = id;
	_tmp5_ = g_strdup_printf ("\n" \
"            UPDATE tasks SET priority = priority+1\n" \
"            WHERE\n" \
"                id = %d\n" \
"        ", _tmp4_);
	sql = _tmp5_;
	_tmp6_ = self->priv->db;
	_tmp7_ = sql;
	_tmp9_ = _sqlite3_exec (_tmp6_, _tmp7_, NULL, NULL, &_tmp8_);
	_g_free0 (errmsg);
	errmsg = _tmp8_;
	rc = _tmp9_;
	_tmp10_ = rc;
	if (_tmp10_ != SQLITE_OK) {
		FILE* _tmp11_;
		const gchar* _tmp12_;
		_tmp11_ = stderr;
		_tmp12_ = errmsg;
		fprintf (_tmp11_, "Database Error: %s\n", _tmp12_);
		result = 0;
		_g_free0 (sql);
		_g_free0 (errmsg);
		return result;
	}
	result = 1;
	_g_free0 (sql);
	_g_free0 (errmsg);
	return result;
}


gint storage_task_priority_down (Storage* self, gint id) {
	gint result = 0;
	gchar* errmsg = NULL;
	gint _tmp0_;
	gint _tmp1_ = 0;
	gint current_priority;
	gint _tmp2_;
	gint _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* sql;
	sqlite3* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gint rc;
	gint _tmp9_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = id;
	_tmp1_ = storage_get_task_priority (self, _tmp0_);
	current_priority = _tmp1_;
	_tmp2_ = current_priority;
	if (_tmp2_ == 0) {
		result = 0;
		_g_free0 (errmsg);
		return result;
	}
	_tmp3_ = id;
	_tmp4_ = g_strdup_printf ("\n" \
"            UPDATE tasks SET priority = priority - 1\n" \
"            WHERE\n" \
"                id = %d\n" \
"        ", _tmp3_);
	sql = _tmp4_;
	_tmp5_ = self->priv->db;
	_tmp6_ = sql;
	_tmp8_ = _sqlite3_exec (_tmp5_, _tmp6_, NULL, NULL, &_tmp7_);
	_g_free0 (errmsg);
	errmsg = _tmp7_;
	rc = _tmp8_;
	_tmp9_ = rc;
	if (_tmp9_ != SQLITE_OK) {
		FILE* _tmp10_;
		const gchar* _tmp11_;
		_tmp10_ = stderr;
		_tmp11_ = errmsg;
		fprintf (_tmp10_, "Database Error: %s\n", _tmp11_);
		result = 0;
		_g_free0 (sql);
		_g_free0 (errmsg);
		return result;
	}
	result = 1;
	_g_free0 (sql);
	_g_free0 (errmsg);
	return result;
}


gboolean storage_task_unmark (Storage* self, gint id, const gchar* marker) {
	gboolean result = FALSE;
	gchar* _tmp0_;
	gchar* stripped;
	GRegex* regex = NULL;
	gint _tmp10_;
	Task* _tmp11_ = NULL;
	Task* t;
	Task* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp26_;
	gchar* errmsg = NULL;
	const gchar* _tmp27_;
	gint _tmp28_;
	gchar* _tmp29_ = NULL;
	gchar* sql;
	sqlite3* _tmp30_;
	const gchar* _tmp31_;
	gchar* _tmp32_ = NULL;
	gint _tmp33_ = 0;
	gint rc;
	gint _tmp34_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (marker != NULL, FALSE);
	_tmp0_ = g_strdup ("");
	stripped = _tmp0_;
	{
		const gchar* _tmp1_;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		GRegex* _tmp4_;
		GRegex* _tmp5_;
		GRegex* _tmp6_;
		_tmp1_ = marker;
		_tmp2_ = g_strdup_printf ("\\%s\\s+", _tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_regex_new (_tmp3_, 0, 0, &_inner_error_);
		_tmp5_ = _tmp4_;
		_g_free0 (_tmp3_);
		_tmp6_ = _tmp5_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch2_g_regex_error;
			}
			_g_regex_unref0 (regex);
			_g_free0 (stripped);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_g_regex_unref0 (regex);
		regex = _tmp6_;
	}
	goto __finally2;
	__catch2_g_regex_error:
	{
		GError* e = NULL;
		FILE* _tmp7_;
		GError* _tmp8_;
		const gchar* _tmp9_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = stdout;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		fprintf (_tmp7_, "ERROR: %s\n", _tmp9_);
		result = FALSE;
		_g_error_free0 (e);
		_g_regex_unref0 (regex);
		_g_free0 (stripped);
		return result;
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_regex_unref0 (regex);
		_g_free0 (stripped);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp10_ = id;
	_tmp11_ = storage_get_task (self, _tmp10_);
	t = _tmp11_;
	_tmp12_ = t;
	_tmp13_ = _tmp12_->task;
	if (g_strcmp0 (_tmp13_, "") == 0) {
		result = FALSE;
		_g_object_unref0 (t);
		_g_regex_unref0 (regex);
		_g_free0 (stripped);
		return result;
	}
	{
		GRegex* _tmp14_;
		Task* _tmp15_;
		const gchar* _tmp16_;
		Task* _tmp17_;
		const gchar* _tmp18_;
		gint _tmp19_;
		gint _tmp20_;
		gchar* _tmp21_ = NULL;
		gchar* _tmp22_;
		_tmp14_ = regex;
		_tmp15_ = t;
		_tmp16_ = _tmp15_->task;
		_tmp17_ = t;
		_tmp18_ = _tmp17_->task;
		_tmp19_ = strlen (_tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = g_regex_replace (_tmp14_, _tmp16_, (gssize) _tmp20_, 0, "", 0, &_inner_error_);
		_tmp22_ = _tmp21_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch3_g_regex_error;
			}
			_g_object_unref0 (t);
			_g_regex_unref0 (regex);
			_g_free0 (stripped);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_g_free0 (stripped);
		stripped = _tmp22_;
	}
	goto __finally3;
	__catch3_g_regex_error:
	{
		GError* e = NULL;
		FILE* _tmp23_;
		GError* _tmp24_;
		const gchar* _tmp25_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp23_ = stdout;
		_tmp24_ = e;
		_tmp25_ = _tmp24_->message;
		fprintf (_tmp23_, "ERROR: %s\n", _tmp25_);
		result = FALSE;
		_g_error_free0 (e);
		_g_object_unref0 (t);
		_g_regex_unref0 (regex);
		_g_free0 (stripped);
		return result;
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (t);
		_g_regex_unref0 (regex);
		_g_free0 (stripped);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp26_ = stripped;
	if (g_strcmp0 (_tmp26_, "") == 0) {
		result = FALSE;
		_g_object_unref0 (t);
		_g_regex_unref0 (regex);
		_g_free0 (stripped);
		return result;
	}
	_tmp27_ = stripped;
	_tmp28_ = id;
	_tmp29_ = g_strdup_printf ("\n" \
"            UPDATE tasks SET task = \"%s\"\n" \
"            WHERE id = %d\n" \
"        ", _tmp27_, _tmp28_);
	sql = _tmp29_;
	_tmp30_ = self->priv->db;
	_tmp31_ = sql;
	_tmp33_ = _sqlite3_exec (_tmp30_, _tmp31_, NULL, NULL, &_tmp32_);
	_g_free0 (errmsg);
	errmsg = _tmp32_;
	rc = _tmp33_;
	_tmp34_ = rc;
	if (_tmp34_ != SQLITE_OK) {
		FILE* _tmp35_;
		const gchar* _tmp36_;
		_tmp35_ = stderr;
		_tmp36_ = errmsg;
		fprintf (_tmp35_, "Database Error: %s\n", _tmp36_);
		result = FALSE;
		_g_free0 (sql);
		_g_free0 (errmsg);
		_g_object_unref0 (t);
		_g_regex_unref0 (regex);
		_g_free0 (stripped);
		return result;
	}
	result = TRUE;
	_g_free0 (sql);
	_g_free0 (errmsg);
	_g_object_unref0 (t);
	_g_regex_unref0 (regex);
	_g_free0 (stripped);
	return result;
}


gboolean storage_unresolve_task (Storage* self, gint id) {
	gboolean result = FALSE;
	gchar* errmsg = NULL;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* sql;
	sqlite3* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gint rc;
	gint _tmp6_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = id;
	_tmp1_ = g_strdup_printf ("\n" \
"            UPDATE tasks SET resolved = NULL\n" \
"            WHERE\n" \
"                id = %d\n" \
"        ", _tmp0_);
	sql = _tmp1_;
	_tmp2_ = self->priv->db;
	_tmp3_ = sql;
	_tmp5_ = _sqlite3_exec (_tmp2_, _tmp3_, NULL, NULL, &_tmp4_);
	_g_free0 (errmsg);
	errmsg = _tmp4_;
	rc = _tmp5_;
	_tmp6_ = rc;
	if (_tmp6_ != SQLITE_OK) {
		FILE* _tmp7_;
		const gchar* _tmp8_;
		_tmp7_ = stderr;
		_tmp8_ = errmsg;
		fprintf (_tmp7_, "Database Error: %s\n", _tmp8_);
		result = FALSE;
		_g_free0 (sql);
		_g_free0 (errmsg);
		return result;
	}
	result = TRUE;
	_g_free0 (sql);
	_g_free0 (errmsg);
	return result;
}


gboolean storage_task_mark (Storage* self, gint id, const gchar* marker) {
	gboolean result = FALSE;
	gchar* errmsg = NULL;
	const gchar* _tmp0_;
	gint _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* sql;
	sqlite3* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint rc;
	gint _tmp7_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (marker != NULL, FALSE);
	_tmp0_ = marker;
	_tmp1_ = id;
	_tmp2_ = g_strdup_printf ("\n" \
"            UPDATE tasks SET task = \"%s \" || task\n" \
"            WHERE\n" \
"                id = %d\n" \
"        ", _tmp0_, _tmp1_);
	sql = _tmp2_;
	_tmp3_ = self->priv->db;
	_tmp4_ = sql;
	_tmp6_ = _sqlite3_exec (_tmp3_, _tmp4_, NULL, NULL, &_tmp5_);
	_g_free0 (errmsg);
	errmsg = _tmp5_;
	rc = _tmp6_;
	_tmp7_ = rc;
	if (_tmp7_ != SQLITE_OK) {
		FILE* _tmp8_;
		const gchar* _tmp9_;
		_tmp8_ = stderr;
		_tmp9_ = errmsg;
		fprintf (_tmp8_, "Database Error: %s\n", _tmp9_);
		result = FALSE;
		_g_free0 (sql);
		_g_free0 (errmsg);
		return result;
	}
	result = TRUE;
	_g_free0 (sql);
	_g_free0 (errmsg);
	return result;
}


static gint storage_get_task_priority (Storage* self, gint id) {
	gint result = 0;
	sqlite3_stmt* stmt = NULL;
	gint priority;
	gint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* sql;
	sqlite3* _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	sqlite3_stmt* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gint rc;
	gint _tmp9_;
	g_return_val_if_fail (self != NULL, 0);
	priority = 0;
	_tmp0_ = id;
	_tmp1_ = g_strdup_printf ("\n" \
"            SELECT priority FROM tasks\n" \
"            WHERE\n" \
"                id = %d\n" \
"        ", _tmp0_);
	sql = _tmp1_;
	_tmp2_ = self->priv->db;
	_tmp3_ = sql;
	_tmp4_ = sql;
	_tmp5_ = strlen (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp8_ = sqlite3_prepare_v2 (_tmp2_, _tmp3_, _tmp6_, &_tmp7_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp7_;
	rc = _tmp8_;
	_tmp9_ = rc;
	if (_tmp9_ != SQLITE_OK) {
		FILE* _tmp10_;
		_tmp10_ = stderr;
		fprintf (_tmp10_, "Error while selecting data...");
		result = 0;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	while (TRUE) {
		sqlite3_stmt* _tmp11_;
		gint _tmp12_ = 0;
		sqlite3_stmt* _tmp13_;
		const gchar* _tmp14_ = NULL;
		gint _tmp15_ = 0;
		_tmp11_ = stmt;
		_tmp12_ = sqlite3_step (_tmp11_);
		if (!(_tmp12_ == SQLITE_ROW)) {
			break;
		}
		_tmp13_ = stmt;
		_tmp14_ = sqlite3_column_text (_tmp13_, 0);
		_tmp15_ = atoi (_tmp14_);
		priority = _tmp15_;
	}
	result = priority;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


static void _vala_array_add2 (gint** array, int* length, int* size, gint value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gint, *array, *size);
	}
	(*array)[(*length)++] = value;
}


static gboolean storage_is_task_exists (Storage* self, const gchar* task) {
	gboolean result = FALSE;
	sqlite3_stmt* stmt = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* sql;
	sqlite3* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	sqlite3_stmt* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gint rc;
	gint _tmp12_;
	gint* _tmp14_ = NULL;
	gint* data;
	gint data_length1;
	gint _data_size_;
	gboolean _tmp21_ = FALSE;
	gint* _tmp22_;
	gint _tmp22__length1;
	gboolean _tmp23_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (task != NULL, FALSE);
	_tmp0_ = task;
	_tmp1_ = storage_strip_task (self, _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("SELECT id FROM tasks WHERE task = \"%s\" AND resolved is NULL", _tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	sql = _tmp4_;
	_tmp5_ = self->priv->db;
	_tmp6_ = sql;
	_tmp7_ = sql;
	_tmp8_ = strlen (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp11_ = sqlite3_prepare_v2 (_tmp5_, _tmp6_, _tmp9_, &_tmp10_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp10_;
	rc = _tmp11_;
	_tmp12_ = rc;
	if (_tmp12_ != SQLITE_OK) {
		FILE* _tmp13_;
		_tmp13_ = stderr;
		fprintf (_tmp13_, "Database Error");
		result = FALSE;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	_tmp14_ = g_new0 (gint, 0);
	data = _tmp14_;
	data_length1 = 0;
	_data_size_ = data_length1;
	while (TRUE) {
		sqlite3_stmt* _tmp15_;
		gint _tmp16_ = 0;
		gint* _tmp17_;
		gint _tmp17__length1;
		sqlite3_stmt* _tmp18_;
		const gchar* _tmp19_ = NULL;
		gint _tmp20_ = 0;
		_tmp15_ = stmt;
		_tmp16_ = sqlite3_step (_tmp15_);
		if (!(_tmp16_ == SQLITE_ROW)) {
			break;
		}
		_tmp17_ = data;
		_tmp17__length1 = data_length1;
		_tmp18_ = stmt;
		_tmp19_ = sqlite3_column_text (_tmp18_, 0);
		_tmp20_ = atoi (_tmp19_);
		_vala_array_add2 (&data, &data_length1, &_data_size_, _tmp20_);
	}
	_tmp22_ = data;
	_tmp22__length1 = data_length1;
	if (_tmp22__length1 == 0) {
		_tmp21_ = FALSE;
	} else {
		_tmp21_ = TRUE;
	}
	_tmp23_ = _tmp21_;
	result = _tmp23_;
	data = (g_free (data), NULL);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


static void _vala_array_add3 (Task*** array, int* length, int* size, Task* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (Task*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add4 (Task*** array, int* length, int* size, Task* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (Task*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


Task* storage_get_task (Storage* self, gint id) {
	Task* result = NULL;
	sqlite3_stmt* stmt = NULL;
	Task** _tmp0_ = NULL;
	Task** tasks;
	gint tasks_length1;
	gint _tasks_size_;
	gint _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* sql;
	sqlite3* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	sqlite3_stmt* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	gint rc;
	gint _tmp10_;
	Task** _tmp25_;
	gint _tmp25__length1;
	Task** _tmp30_;
	gint _tmp30__length1;
	Task* _tmp31_;
	Task* _tmp32_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_new0 (Task*, 0 + 1);
	tasks = _tmp0_;
	tasks_length1 = 0;
	_tasks_size_ = tasks_length1;
	_tmp1_ = id;
	_tmp2_ = g_strdup_printf ("SELECT task FROM tasks WHERE id = %d", _tmp1_);
	sql = _tmp2_;
	_tmp3_ = self->priv->db;
	_tmp4_ = sql;
	_tmp5_ = sql;
	_tmp6_ = strlen (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp9_ = sqlite3_prepare_v2 (_tmp3_, _tmp4_, _tmp7_, &_tmp8_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp8_;
	rc = _tmp9_;
	_tmp10_ = rc;
	if (_tmp10_ != SQLITE_OK) {
		FILE* _tmp11_;
		_tmp11_ = stderr;
		fprintf (_tmp11_, "Error while selecting data...");
	}
	while (TRUE) {
		sqlite3_stmt* _tmp12_;
		gint _tmp13_ = 0;
		sqlite3_stmt* _tmp14_;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_;
		gchar* task_str;
		const gchar* _tmp17_;
		gint _tmp19_;
		const gchar* _tmp20_;
		Task* _tmp21_;
		Task* t;
		Task** _tmp22_;
		gint _tmp22__length1;
		Task* _tmp23_;
		Task* _tmp24_;
		_tmp12_ = stmt;
		_tmp13_ = sqlite3_step (_tmp12_);
		if (!(_tmp13_ == SQLITE_ROW)) {
			break;
		}
		_tmp14_ = stmt;
		_tmp15_ = sqlite3_column_text (_tmp14_, 0);
		_tmp16_ = g_strdup (_tmp15_);
		task_str = _tmp16_;
		_tmp17_ = task_str;
		if (g_strcmp0 (_tmp17_, "") == 0) {
			FILE* _tmp18_;
			_tmp18_ = stdout;
			fprintf (_tmp18_, "NULL!");
		}
		_tmp19_ = id;
		_tmp20_ = task_str;
		_tmp21_ = task_new (_tmp19_, _tmp20_);
		t = _tmp21_;
		_tmp22_ = tasks;
		_tmp22__length1 = tasks_length1;
		_tmp23_ = t;
		_tmp24_ = _g_object_ref0 (_tmp23_);
		_vala_array_add3 (&tasks, &tasks_length1, &_tasks_size_, _tmp24_);
		_g_object_unref0 (t);
		_g_free0 (task_str);
	}
	_tmp25_ = tasks;
	_tmp25__length1 = tasks_length1;
	if (_tmp25__length1 == 0) {
		Task* _tmp26_;
		Task* t;
		Task** _tmp27_;
		gint _tmp27__length1;
		Task* _tmp28_;
		Task* _tmp29_;
		_tmp26_ = task_new (0, "");
		t = _tmp26_;
		_tmp27_ = tasks;
		_tmp27__length1 = tasks_length1;
		_tmp28_ = t;
		_tmp29_ = _g_object_ref0 (_tmp28_);
		_vala_array_add4 (&tasks, &tasks_length1, &_tasks_size_, _tmp29_);
		_g_object_unref0 (t);
	}
	_tmp30_ = tasks;
	_tmp30__length1 = tasks_length1;
	_tmp31_ = _tmp30_[0];
	_tmp32_ = _g_object_ref0 (_tmp31_);
	result = _tmp32_;
	_g_free0 (sql);
	tasks = (_vala_array_free (tasks, tasks_length1, (GDestroyNotify) g_object_unref), NULL);
	_sqlite3_finalize0 (stmt);
	return result;
}


static void storage_class_init (StorageClass * klass) {
	storage_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (StoragePrivate));
	G_OBJECT_CLASS (klass)->finalize = storage_finalize;
}


static void storage_instance_init (Storage * self) {
	self->priv = STORAGE_GET_PRIVATE (self);
	self->priv->MAX_PRIORITY_VAL = 3;
}


static void storage_finalize (GObject* obj) {
	Storage * self;
	self = STORAGE (obj);
	_sqlite3_close0 (self->priv->db);
	G_OBJECT_CLASS (storage_parent_class)->finalize (obj);
}


GType storage_get_type (void) {
	static volatile gsize storage_type_id__volatile = 0;
	if (g_once_init_enter (&storage_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (StorageClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) storage_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Storage), 0, (GInstanceInitFunc) storage_instance_init, NULL };
		GType storage_type_id;
		storage_type_id = g_type_register_static (G_TYPE_OBJECT, "Storage", &g_define_type_info, 0);
		g_once_init_leave (&storage_type_id__volatile, storage_type_id);
	}
	return storage_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



